<?xml version="1.0" encoding="UTF-8"?>
<!--<?xml version="1.0" encoding="UTF-8"?>-->
<svg xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript"><![CDATA[
if (typeof module !== 'undefined' && module.exports) { // Node.js execution
  const http = require('http');
  const fs = require('fs');
  const path = require('path');
  const { exec } = require('child_process');
  
  // Try to load optional dependencies
  let chokidar, sharp, pdf2svg;
  try {
    chokidar = require('chokidar');
  } catch (e) {
    console.log('Warning: chokidar not installed. Install with: npm install chokidar');
  }
  try {
    sharp = require('sharp');
  } catch (e) {
    console.log('Warning: sharp not installed. Install with: npm install sharp');
  }
  
  const monitoredFolders = new Map();
  const fileCache = new Map();
  
  // Find available port
  async function findAvailablePort(startPort = 3030) {
    const net = require('net');
    
    return new Promise((resolve) => {
      const tryPort = (port) => {
        const server = net.createServer();
        
        server.listen(port, () => {
          server.close(() => {
            resolve(port);
          });
        });
        
        server.on('error', (err) => {
          if (err.code === 'EADDRINUSE') {
            tryPort(port + 1);
          } else {
            resolve(startPort);
          }
        });
      };
      
      tryPort(startPort);
    });
  }
  
  let PORT = 3030;
  
  // Read this file content for serving
  const svgContent = fs.readFileSync(__filename, 'utf8')
    .replace(/^<\?xml[^>]*>\s*<!--<\?xml[^>]*>-->\s*<svg[^>]*>\s*<script[^>]*><!\[CDATA\[[\s\S]*?\]\]><\/script>\s*<!--<\/svg>-->\s*<!--/, '')
    .replace(/^[\s\S]*?<!--\?xml version="1\.0" encoding="UTF-8"\?>\s*/, '<?xml version="1.0" encoding="UTF-8"?>\n');
  
  // Create HTTP server
  const server = http.createServer((req, res) => {
    const url = new URL(req.url, `http://localhost:${PORT}`);
    
    // CORS headers for direct SVG file access
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    // Serve main SVG app
    if (url.pathname === '/') {
      res.writeHead(200, { 
        'Content-Type': 'image/svg+xml',
        'Cache-Control': 'no-cache'
      });
      res.end(svgContent);
      return;
    }
    
    // API endpoints
    if (url.pathname.startsWith('/api/')) {
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Access-Control-Allow-Origin', '*');
      
      switch (url.pathname) {
        case '/api/folders':
          if (req.method === 'GET') {
            res.end(JSON.stringify({
              folders: Array.from(monitoredFolders.keys())
            }));
          } else if (req.method === 'POST') {
            let body = '';
            req.on('data', chunk => body += chunk);
            req.on('end', () => {
              try {
                const { path: folderPath } = JSON.parse(body);
                if (fs.existsSync(folderPath) && fs.statSync(folderPath).isDirectory()) {
                  addMonitoredFolder(folderPath);
                  res.end(JSON.stringify({ success: true }));
                } else {
                  res.statusCode = 400;
                  res.end(JSON.stringify({ error: 'Invalid folder path' }));
                }
              } catch (error) {
                res.statusCode = 400;
                res.end(JSON.stringify({ error: error.message }));
              }
            });
          }
          break;
          
        case '/api/files':
          const folder = url.searchParams.get('folder');
          if (folder && monitoredFolders.has(folder)) {
            const files = scanFolder(folder);
            res.end(JSON.stringify({ files }));
          } else {
            res.statusCode = 404;
            res.end(JSON.stringify({ error: 'Folder not found' }));
          }
          break;
          
        case '/api/convert-pdf':
          if (req.method === 'POST') {
            let body = '';
            req.on('data', chunk => body += chunk);
            req.on('end', async () => {
              try {
                const { filePath } = JSON.parse(body);
                const svgPath = await convertPdfToSvg(filePath);
                res.end(JSON.stringify({ success: true, svgPath }));
              } catch (error) {
                res.statusCode = 500;
                res.end(JSON.stringify({ error: error.message }));
              }
            });
          }
          break;
          
        case '/api/thumbnail':
          const filePath = url.searchParams.get('file');
          if (filePath && fs.existsSync(filePath)) {
            generateThumbnail(filePath)
              .then(thumbnail => {
                res.setHeader('Content-Type', 'image/png');
                res.end(thumbnail);
              })
              .catch(error => {
                console.error('Thumbnail error:', error);
                // Send placeholder image
                res.setHeader('Content-Type', 'image/svg+xml');
                res.end(createPlaceholderThumbnail(path.extname(filePath)));
              });
          } else {
            res.statusCode = 404;
            res.end();
          }
          break;
          
        case '/api/remove-folder':
          if (req.method === 'POST') {
            let body = '';
            req.on('data', chunk => body += chunk);
            req.on('end', () => {
              try {
                const { path: folderPath } = JSON.parse(body);
                removeMonitoredFolder(folderPath);
                res.end(JSON.stringify({ success: true }));
              } catch (error) {
                res.statusCode = 400;
                res.end(JSON.stringify({ error: error.message }));
              }
            });
          }
          break;
          
        default:
          res.statusCode = 404;
          res.end(JSON.stringify({ error: 'Not found' }));
      }
      return;
    }
    
    // Serve static files
    if (url.pathname.startsWith('/files/')) {
      const filePath = decodeURIComponent(url.pathname.substring(7));
      if (fs.existsSync(filePath) && fs.statSync(filePath).isFile()) {
        const ext = path.extname(filePath).toLowerCase();
        const contentTypes = {
          '.svg': 'image/svg+xml',
          '.png': 'image/png',
          '.jpg': 'image/jpeg',
          '.jpeg': 'image/jpeg',
          '.pdf': 'application/pdf'
        };
        
        res.setHeader('Content-Type', contentTypes[ext] || 'application/octet-stream');
        res.setHeader('Content-Disposition', `inline; filename="${path.basename(filePath)}"`);
        fs.createReadStream(filePath).pipe(res);
      } else {
        res.statusCode = 404;
        res.end();
      }
      return;
    }
    
    res.statusCode = 404;
    res.end();
  });
  
  // Folder monitoring functions
  function addMonitoredFolder(folderPath) {
    if (monitoredFolders.has(folderPath)) return;
    
    console.log(`Adding folder to monitor: ${folderPath}`);
    
    if (chokidar) {
      const watcher = chokidar.watch(folderPath, {
        persistent: true,
        ignoreInitial: true,
        depth: 2
      });
      
      watcher.on('add', filePath => {
        console.log(`File added: ${filePath}`);
        if (path.extname(filePath).toLowerCase() === '.pdf') {
          // Auto-convert new PDFs
          setTimeout(() => {
            convertPdfToSvg(filePath).catch(console.error);
          }, 1000);
        }
      });
      
      watcher.on('change', filePath => {
        console.log(`File changed: ${filePath}`);
        fileCache.delete(filePath);
      });
      
      watcher.on('unlink', filePath => {
        console.log(`File removed: ${filePath}`);
        fileCache.delete(filePath);
      });
      
      monitoredFolders.set(folderPath, watcher);
    } else {
      // Fallback: just track the folder without watching
      monitoredFolders.set(folderPath, null);
    }
  }
  
  function removeMonitoredFolder(folderPath) {
    if (monitoredFolders.has(folderPath)) {
      const watcher = monitoredFolders.get(folderPath);
      if (watcher) watcher.close();
      monitoredFolders.delete(folderPath);
      console.log(`Removed folder from monitoring: ${folderPath}`);
    }
  }
  
  function scanFolder(folderPath) {
    const files = [];
    
    function scanDir(dir, level = 0) {
      if (level > 2) return;
      
      try {
        const items = fs.readdirSync(dir);
        items.forEach(item => {
          if (item.startsWith('.')) return; // Skip hidden files
          
          const fullPath = path.join(dir, item);
          try {
            const stat = fs.statSync(fullPath);
            
            if (stat.isDirectory()) {
              scanDir(fullPath, level + 1);
            } else {
              const ext = path.extname(item).toLowerCase();
              if (['.pdf', '.svg', '.png', '.jpg', '.jpeg'].includes(ext)) {
                files.push({
                  name: item,
                  path: fullPath,
                  size: stat.size,
                  modified: stat.mtime,
                  type: ext.substring(1)
                });
              }
            }
          } catch (err) {
            console.error(`Error accessing ${fullPath}:`, err.message);
          }
        });
      } catch (error) {
        console.error(`Error scanning ${dir}:`, error.message);
      }
    }
    
    scanDir(folderPath);
    return files.sort((a, b) => b.modified - a.modified);
  }
  
  async function convertPdfToSvg(pdfPath) {
    const svgPath = pdfPath.replace(/\.pdf$/i, '.svg');
    
    return new Promise((resolve, reject) => {
      // Try pdf2svg first
      exec(`pdf2svg "${pdfPath}" "${svgPath}" 1`, (error, stdout, stderr) => {
        if (!error) {
          console.log(`Converted: ${pdfPath} -> ${svgPath}`);
          resolve(svgPath);
        } else {
          // Fallback to ImageMagick convert
          exec(`convert -density 150 "${pdfPath}[0]" "${svgPath}"`, (error2, stdout2, stderr2) => {
            if (!error2) {
              console.log(`Converted with ImageMagick: ${pdfPath} -> ${svgPath}`);
              resolve(svgPath);
            } else {
              reject(new Error('PDF conversion failed. Install pdf2svg or ImageMagick.'));
            }
          });
        }
      });
    });
  }
  
  async function generateThumbnail(filePath) {
    const ext = path.extname(filePath).toLowerCase();
    
    if (fileCache.has(filePath)) {
      return fileCache.get(filePath);
    }
    
    let thumbnail;
    
    try {
      if (sharp) {
        if (['.png', '.jpg', '.jpeg'].includes(ext)) {
          thumbnail = await sharp(filePath)
            .resize(200, 200, { 
              fit: 'contain', 
              background: { r: 255, g: 255, b: 255, alpha: 1 }
            })
            .png()
            .toBuffer();
        } else if (ext === '.svg') {
          // Sharp can handle SVG
          thumbnail = await sharp(filePath)
            .resize(200, 200, { 
              fit: 'contain',
              background: { r: 255, g: 255, b: 255, alpha: 1 }
            })
            .png()
            .toBuffer();
        } else if (ext === '.pdf') {
          // Generate thumbnail from first page of PDF using ImageMagick
          const tempPng = filePath.replace(/\.pdf$/i, '_thumb_temp.png');
          await new Promise((resolve, reject) => {
            exec(`magick convert -density 72 -quality 80 "${filePath}[0]" -resize 200x200 -background white -flatten "${tempPng}"`, (error) => {
              if (error) reject(error);
              else resolve();
            });
          });
          
          if (fs.existsSync(tempPng)) {
            thumbnail = await fs.promises.readFile(tempPng);
            await fs.promises.unlink(tempPng);
          }
        }
      }
      
      if (thumbnail) {
        fileCache.set(filePath, thumbnail);
        return thumbnail;
      }
    } catch (error) {
      console.error(`Error generating thumbnail for ${filePath}:`, error.message);
    }
    
    // Return placeholder if thumbnail generation fails
    return Buffer.from(createPlaceholderThumbnail(ext));
  }
  
  function createPlaceholderThumbnail(ext) {
    const colors = {
      '.pdf': '#dc2626',
      '.svg': '#8b5cf6',
      '.png': '#10b981',
      '.jpg': '#10b981',
      '.jpeg': '#10b981'
    };
    
    const color = colors[ext] || '#6b7280';
    const label = ext.substring(1).toUpperCase();
    
    return `<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 200 200">
      <rect width="200" height="200" fill="#f3f4f6"/>
      <rect x="50" y="40" width="100" height="120" fill="${color}" opacity="0.2" rx="4"/>
      <text x="100" y="110" text-anchor="middle" font-family="system-ui" font-size="24" font-weight="bold" fill="${color}">${label}</text>
    </svg>`;
  }
  
  // Start server
  async function startServer() {
    PORT = await findAvailablePort(process.env.PORT || 3030);
    
    server.listen(PORT, () => {
      const portInfo = PORT !== 3030 ? ` (port ${PORT})` : '';
      console.log(`
╔═══════════════════════════════════════════╗
║        File Monitor PWA Server            ║
║                                           ║
║  Running at: http://localhost:${PORT}${' '.repeat(12 - PORT.toString().length - portInfo.length)}   ║
║                                           ║
║  Features:                                ║
║  • Monitor folders for changes            ║
║  • Auto-convert PDF to SVG                ║
║  • Generate file thumbnails               ║
║  • Grid and list views                    ║
║                                           ║
║  Press Ctrl+C to stop                     ║
╚═══════════════════════════════════════════╝
`);
      
      if (PORT !== 3030) {
        console.log(`Note: Port 3030 was busy, using port ${PORT} instead.\n`);
      }
      
      // Add current directory as default monitored folder
      addMonitoredFolder(process.cwd());
    });
  }
  
  startServer();
  
  // Cleanup on exit
  process.on('SIGINT', () => {
    console.log('\nShutting down...');
    monitoredFolders.forEach(watcher => {
      if (watcher) watcher.close();
    });
    server.close(() => {
      console.log('Server closed');
      process.exit(0);
    });
  });
  
  return;
} else { // Browser context
  // When opened directly in browser, redirect to server
  if (window.location.protocol === 'file:') {
    document.body.innerHTML = `
      <div style="font-family: system-ui; padding: 50px; text-align: center;">
        <h1>File Monitor PWA</h1>
        <p>This SVG file is a Node.js application.</p>
        <p>To use it:</p>
        <ol style="text-align: left; max-width: 500px; margin: 20px auto;">
          <li>Save this file as <code>file-monitor.svg</code></li>
          <li>Open terminal and run: <code>node file-monitor.svg</code></li>
          <li>Open browser at: <a href="http://localhost:3030">http://localhost:3030</a></li>
        </ol>
        <p style="color: #666; margin-top: 30px;">
          The application will find an available port if 3030 is busy.
        </p>
      </div>
    `;
    // Exit to prevent SVG rendering
    throw new Error('Redirect message shown');
  }
}

// Client-side code for browser
if (typeof window !== 'undefined' && window.document) {
  // Global variables
  let files = [];
  let currentFolder = '';
  let monitoredFolders = [];
  let currentView = 'grid';
  let searchQuery = '';
  
  // DOM elements
  const folderList = document.getElementById('folder-list');
  const gridView = document.getElementById('grid-view');
  const listView = document.getElementById('list-view');
  const breadcrumb = document.getElementById('breadcrumb');
  const statusText = document.getElementById('status-text');
  const fileCount = document.getElementById('file-count');
  const loadingOverlay = document.getElementById('loading-overlay');
  
  // Initialize
  async function init() {
    await loadMonitoredFolders();
    setupEventListeners();
    updateStatus('Ready to monitor files');
    
    // Auto-refresh every 10 seconds
    setInterval(() => {
      if (currentFolder) {
        loadFiles(false);
      }
    }, 10000);
  }
  
  // Load monitored folders
  async function loadMonitoredFolders() {
    addLog('Loading monitored folders...', 'INFO');
    try {
      const response = await fetch('/api/folders');
      const data = await response.json();
      monitoredFolders = data.folders || [];
      renderFolderList();
      
      if (!currentFolder && monitoredFolders.length > 0) {
        addLog(`Auto-selecting first folder: ${monitoredFolders[0]}`, 'INFO');
        await selectFolder(monitoredFolders[0]);
      }
    } catch (error) {
      console.error('Error loading folders:', error);
      updateStatus('Failed to load folders', true);
    }
  }
  
  // Select folder
  async function selectFolder(folder) {
    currentFolder = folder;
    breadcrumb.textContent = folder;
    renderFolderList();
    await loadFiles();
    addLog(`Selected folder: ${folder}`, 'INFO');
  }
  
  // Load files from selected folder
  async function loadFiles(showLoader = true) {
    if (!currentFolder) return;
    
    if (showLoader) showLoading(true);
    addLog(`Loading files from: ${currentFolder}`, 'INFO');
    
    try {
      const response = await fetch(`/api/files?folder=${encodeURIComponent(currentFolder)}`);
      const data = await response.json();
      files = data.files || [];
      
      renderFiles();
      updateStatus(`Found ${files.length} files`);
      fileCount.textContent = `${files.length} files`;
      addLog(`Loaded ${files.length} files`, 'SUCCESS');
    } catch (error) {
      console.error('Error loading files:', error);
      updateStatus('Failed to load files', true);
      addLog(`Error loading files: ${error.message}`, 'ERROR');
    } finally {
      if (showLoader) showLoading(false);
    }
  }
  
  // Render files based on current view
  function renderFiles() {
    if (currentView === 'grid') {
      gridView.style.display = 'block';
      listView.style.display = 'none';
      renderGridView();
    } else {
      gridView.style.display = 'none';
      listView.style.display = 'block';
      renderListView();
    }
  }
  
  // Render folder list
  function renderFolderList() {
    folderList.innerHTML = '';
    
    if (monitoredFolders.length === 0) {
      const emptyMsg = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      emptyMsg.setAttribute('x', '115');
      emptyMsg.setAttribute('y', '100');
      emptyMsg.setAttribute('text-anchor', 'middle');
      emptyMsg.setAttribute('font-family', 'system-ui');
      emptyMsg.setAttribute('font-size', '13');
      emptyMsg.setAttribute('fill', '#94a3b8');
      emptyMsg.textContent = 'No folders monitored';
      folderList.appendChild(emptyMsg);
      return;
    }
    
    monitoredFolders.forEach((folder, index) => {
      const folderGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      folderGroup.setAttribute('transform', `translate(0, ${index * 60})`);
      
      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.setAttribute('class', currentFolder === folder ? 'folder-item folder-item-active' : 'folder-item');
      rect.setAttribute('width', '230');
      rect.setAttribute('height', '50');
      rect.setAttribute('rx', '6');
      
      const folderIcon = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      folderIcon.setAttribute('x', '15');
      folderIcon.setAttribute('y', '30');
      folderIcon.setAttribute('font-size', '20');
      folderIcon.textContent = '📁';
      
      const folderName = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      folderName.setAttribute('x', '45');
      folderName.setAttribute('y', '20');
      folderName.setAttribute('font-family', 'system-ui');
      folderName.setAttribute('font-size', '13');
      folderName.setAttribute('font-weight', '500');
      folderName.setAttribute('fill', '#1e293b');
      
      const parts = folder.split(/[\/]/);
      const name = parts[parts.length - 1] || folder;
      folderName.textContent = name.length > 18 ? name.substring(0, 18) + '...' : name;
      
      const folderPath = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      folderPath.setAttribute('x', '45');
      folderPath.setAttribute('y', '38');
      folderPath.setAttribute('font-family', 'system-ui');
      folderPath.setAttribute('font-size', '11');
      folderPath.setAttribute('fill', '#64748b');
      folderPath.textContent = '...' + folder.slice(-25);
      
      folderGroup.addEventListener('click', () => selectFolder(folder));
      
      folderGroup.appendChild(rect);
      folderGroup.appendChild(folderIcon);
      folderGroup.appendChild(folderName);
      folderGroup.appendChild(folderPath);
      
      folderList.appendChild(folderGroup);
    });
  }
  
  // Render grid view
  function renderGridView() {
    gridView.innerHTML = '';
    
    if (files.length === 0) {
      const emptyMsg = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      emptyMsg.setAttribute('x', '550');
      emptyMsg.setAttribute('y', '300');
      emptyMsg.setAttribute('text-anchor', 'middle');
      emptyMsg.setAttribute('font-family', 'system-ui');
      emptyMsg.setAttribute('font-size', '16');
      emptyMsg.setAttribute('fill', '#94a3b8');
      emptyMsg.textContent = 'No files found';
      gridView.appendChild(emptyMsg);
      return;
    }
    
    files.forEach((file, index) => {
      const col = index % 5;
      const row = Math.floor(index / 5);
      const x = col * 220;
      const y = row * 250;
      
      const fileGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      fileGroup.setAttribute('transform', `translate(${x}, ${y})`);
      
      const card = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      card.setAttribute('class', 'file-item');
      card.setAttribute('width', '200');
      card.setAttribute('height', '230');
      card.setAttribute('rx', '8');
      card.setAttribute('fill', 'white');
      card.setAttribute('stroke', '#e2e8f0');
      
      const thumbContainer = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      thumbContainer.setAttribute('x', '10');
      thumbContainer.setAttribute('y', '10');
      thumbContainer.setAttribute('width', '180');
      thumbContainer.setAttribute('height', '160');
      thumbContainer.setAttribute('rx', '4');
      thumbContainer.setAttribute('fill', '#f3f4f6');
      
      if (['png', 'jpg', 'jpeg', 'svg', 'pdf'].includes(file.type)) {
        const thumbnail = document.createElementNS('http://www.w3.org/2000/svg', 'image');
        thumbnail.setAttribute('x', '10');
        thumbnail.setAttribute('y', '10');
        thumbnail.setAttribute('width', '180');
        thumbnail.setAttribute('height', '160');
        thumbnail.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        
        fetch(`/api/thumbnail?file=${encodeURIComponent(file.path)}`)
          .then(response => response.blob())
          .then(blob => {
            const reader = new FileReader();
            reader.onload = () => thumbnail.setAttribute('href', reader.result);
            reader.readAsDataURL(blob);
          })
          .catch(() => {
            thumbnail.setAttribute('href', 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJzeXN0ZW0tdWkiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM5NGEzYjgiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiPu+4jzwvdGV4dD48L3N2Zz4=');
          });
        
        fileGroup.appendChild(thumbnail);
      }
      
      const fileName = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      fileName.setAttribute('x', '20');
      fileName.setAttribute('y', '190');
      fileName.setAttribute('font-family', 'system-ui');
      fileName.setAttribute('font-size', '13');
      fileName.setAttribute('fill', '#1e293b');
      fileName.textContent = file.name.length > 20 ? file.name.substring(0, 17) + '...' : file.name;
      
      fileGroup.appendChild(card);
      fileGroup.appendChild(thumbContainer);
      fileGroup.appendChild(fileName);
      
      gridView.appendChild(fileGroup);
    });
  }
  
  // Render list view
  function renderListView() {
    if (listView) {
      listView.innerHTML = '';
    }
  }
  
  // Update status
  function updateStatus(message, isError = false) {
    if (statusText) {
      statusText.textContent = message;
      statusText.setAttribute('fill', isError ? '#ef4444' : '#64748b');
    }
  }
  
  // Show/hide loading
  function showLoading(show) {
    if (loadingOverlay) {
      loadingOverlay.style.display = show ? 'block' : 'none';
    }
  }
  
  // Add log entry
  function addLog(message, type = 'INFO') {
    console.log(`[${type}] ${message}`);
  }
  
  // Setup event listeners
  function setupEventListeners() {
    // Add any additional event listeners here
  }
  
  // Initialize app
  init();
}
]]></script>
</svg>
